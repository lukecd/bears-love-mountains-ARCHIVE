<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Mountain Trip</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				background: white;
			}
			#canvas1 {
				border: 2px solid white;
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}
		</style>
	</head>
	<body>
		<canvas id="canvas1"></canvas>

		<script>
			let myImage = new Image();
			myImage.src = "../bearslovemountains-1.png";

			myImage.addEventListener("load", function () {
				const canvas = document.getElementById("canvas1");
				const ctx = canvas.getContext("2d");

				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;

				ctx.drawImage(myImage, 0, 0, canvas.width, canvas.height);
				const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				let particleArray = [];
				const numberOfParticles = 5000;

				let mappedImage = [];
				for (let y = 0; y < canvas.height; y++) {
					let row = [];
					for (let x = 0; x < canvas.width; x++) {
						const red = pixels.data[y * 4 * pixels.width + x * 4];
						const green = pixels.data[y * 4 * pixels.width + (x * 4 + 1)];
						const blue = pixels.data[y * 4 * pixels.width + (x * 4 + 2)];
						const brightness = calculateRelativeBrightness(red, green, blue);
						const cell = [(cellBrightness = brightness), (cellColor = `rgb(${red}, ${green}, ${blue})`)];
						row.push(cell);
					}
					mappedImage.push(row);
				}
				function calculateRelativeBrightness(red, green, blue) {
					return Math.sqrt(red * red * 0.299 + green * green + 0.587 + blue * blue + 0.114) / 100;
				}

				class Particle {
					constructor() {
						this.x = Math.random() * canvas.width;
						this.y = 0;
						this.speed = 0;
						this.velocity = Math.random() * 0.5;
						this.size = Math.random() * 1.5 + 1;
						this.strokeSize = Math.floor(Math.random() * 3 + 1);
						this.position1 = Math.floor(this.y);
						this.position2 = Math.floor(this.x);
					}

					// Function to convert an RGB color to HSL
					rgbToHsl(r, g, b) {
						(r /= 255), (g /= 255), (b /= 255);
						const max = Math.max(r, g, b),
							min = Math.min(r, g, b);
						let h,
							s,
							l = (max + min) / 2;

						if (max === min) {
							h = s = 0; // achromatic
						} else {
							const d = max - min;
							s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
							switch (max) {
								case r:
									h = (g - b) / d + (g < b ? 6 : 0);
									break;
								case g:
									h = (b - r) / d + 2;
									break;
								case b:
									h = (r - g) / d + 4;
									break;
							}
							h /= 6;
						}

						return [h, s, l];
					}

					// Function to increase saturation
					increaseSaturation(h, s, l, increment) {
						s = Math.min(s + increment, 1); // Ensure saturation doesn't exceed 100%
						return `hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
					}
					update() {
						this.position1 = Math.abs(Math.floor(this.y));
						this.position2 = Math.abs(Math.floor(this.x));

						this.speed = mappedImage[this.position1][this.position2][0];
						let movement = 2.5 - this.speed + this.velocity;
						this.size = this.speed * 1.3;

						this.y += movement;
						if (this.y >= canvas.height) {
							this.y = 0;
							this.x = Math.random() * canvas.width;
						}
					}

					draw() {
						ctx.beginPath();
						let rgbColor = mappedImage[this.position1][this.position2][1];
						// Convert RGB string to individual components
						const [r, g, b] = rgbColor.match(/\d+/g).map(Number);
						// Convert RGB to HSL
						const [h, s, l] = this.rgbToHsl(r, g, b);
						// Increase the saturation by 0.2 (20%), for example
						const newColor = this.increaseSaturation(h, s, l, 0.2);

						// Set the new color with increased saturation
						ctx.fillStyle = newColor;
						ctx.fillStyle = mappedImage[this.position1][this.position2][1];
						ctx.strokeStyle = mappedImage[this.position1][this.position2][1];
						ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
						ctx.strokeRect(this.x, this.y, this.size * this.strokeSize, this.size * this.strokeSize);
						ctx.fill();
					}
				} // Particle

				function init() {
					for (let i = 0; i < numberOfParticles; i++) {
						particleArray.push(new Particle());
					}
				}
				init();

				function animate() {
					ctx.drawImage(myImage, 0, 0, canvas.width, canvas.height);

					ctx.globalAlpha = 0.05;
					ctx.fillStyle = "rgb(0, 0, 0)";
					ctx.fillRect(0, 0, canvas.width, canvas.height);

					ctx.globalAlpha = 0.02;
					for (let i = 0; i < particleArray.length; i++) {
						particleArray[i].update();
						ctx.globalAlpha = particleArray[i].speed * 0.5;
						particleArray[i].draw();
					}
					requestAnimationFrame(animate);
				}
				animate();
			});
		</script>
	</body>
</html>
