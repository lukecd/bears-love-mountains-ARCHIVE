<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Complete LSD Effect</title>
		<style>
			canvas {
				width: 100vw;
				height: 100vh;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<script>
			const canvas = document.getElementById("canvas");
			const gl = canvas.getContext("webgl");

			if (!gl) {
				alert("WebGL not supported");
				throw new Error("WebGL not supported");
			}

			// Vertex shader
			// Vertex shader
			const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        varying highp vec2 vTextureCoord;
        void main(void) {
            gl_Position = aVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    `;

			// Fragment shader with saturation increase
			const fsSource = `
        precision mediump float;
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform float time;

        // Function to convert RGB to HSV
        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        // Function to convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

				void main(void) {
					// Adjust coord for a top-to-bottom wave effect
					vec2 coord = vTextureCoord + vec2(0.0, sin(vTextureCoord.x * 20.0 + time) * 0.02);
					vec4 texelColor = texture2D(uSampler, coord);
					vec3 hsv = rgb2hsv(texelColor.rgb);
					hsv.y = min(hsv.y * 2.0, 1.0); // Aggressive saturation increase remains unchanged
					vec3 rgb = hsv2rgb(hsv);
					gl_FragColor = vec4(rgb, 1.0);
			}
    `;

			// Shader compilation
			function compileShader(source, type) {
				const shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
					return null;
				}
				return shader;
			}

			const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
			const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);

			// Shader program
			const shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
			}

			gl.useProgram(shaderProgram);

			const programInfo = {
				attribLocations: {
					vertexPosition: gl.getAttribLocation(shaderProgram, "aVertexPosition"),
					textureCoord: gl.getAttribLocation(shaderProgram, "aTextureCoord"),
				},
				uniformLocations: {
					uSampler: gl.getUniformLocation(shaderProgram, "uSampler"),
					time: gl.getUniformLocation(shaderProgram, "time"),
				},
			};

			// Buffers
			const positionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

			// Texture coordinates adjusted to flip the image right-side up
			const textureCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
			const textureCoordinates = [
				0.0,
				0.0, // Top-left corner
				1.0,
				0.0, // Top-right corner
				0.0,
				1.0, // Bottom-left corner
				1.0,
				1.0, // Bottom-right corner
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);

			// Texture
			const texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);

			// Image
			const image = new Image();
			image.onload = () => {
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

				requestAnimationFrame(render);
			};
			image.src = "../bearslovemountains-1.png";

			let startTime = Date.now();

			function render() {
				const currentTime = Date.now();
				const time = (currentTime - startTime) / 1000.0;

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.clear(gl.COLOR_BUFFER_BIT);

				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
				gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

				gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
				gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
				gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

				gl.uniform1f(programInfo.uniformLocations.time, time);

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

				requestAnimationFrame(render);
			}
		</script>
	</body>
</html>
